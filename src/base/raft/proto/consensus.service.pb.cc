// THIS FILE IS AUTOGENERATED FROM base/raft/proto/consensus.proto

#include "base/raft/proto/consensus.pb.h"
#include "base/raft/proto/consensus.service.pb.h"

#include <glog/logging.h>

#include "base/rpc/inbound_call.h"
#include "base/rpc/remote_method.h"
#include "base/rpc/rpc_context.h"
#include "base/rpc/service_if.h"
#include "base/util/metrics.h"

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_UpdateConsensus,
  "base.consensus.ConsensusService.UpdateConsensus RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.UpdateConsensus() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_RequestConsensusVote,
  "base.consensus.ConsensusService.RequestConsensusVote RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.RequestConsensusVote() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_ChangeConfig,
  "base.consensus.ConsensusService.ChangeConfig RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.ChangeConfig() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_GetNodeInstance,
  "base.consensus.ConsensusService.GetNodeInstance RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.GetNodeInstance() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_RunLeaderElection,
  "base.consensus.ConsensusService.RunLeaderElection RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.RunLeaderElection() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_LeaderStepDown,
  "base.consensus.ConsensusService.LeaderStepDown RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.LeaderStepDown() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_GetLastOpId,
  "base.consensus.ConsensusService.GetLastOpId RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.GetLastOpId() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_GetConsensusState,
  "base.consensus.ConsensusService.GetConsensusState RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.GetConsensusState() RPC requests",
  60000000LU, 2);

METRIC_DEFINE_histogram(server, handler_latency_base_consensus_ConsensusService_StartTabletCopy,
  "base.consensus.ConsensusService.StartTabletCopy RPC Time",
  base::MetricUnit::kMicroseconds,
  "Microseconds spent handling base.consensus.ConsensusService.StartTabletCopy() RPC requests",
  60000000LU, 2);

using google::protobuf::Message;
using base::MetricEntity;
using base::rpc::ResultTracker;
using base::rpc::RpcContext;
using base::rpc::RpcMethodInfo;
using std::unique_ptr;

namespace base {
namespace consensus {

ConsensusServiceIf::ConsensusServiceIf(const scoped_refptr<MetricEntity>& entity, const scoped_refptr<ResultTracker>& result_tracker) {
result_tracker_ = result_tracker;  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new ConsensusRequestPB());
    mi->resp_prototype.reset(new ConsensusResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_UpdateConsensus.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->UpdateConsensus(static_cast<const ConsensusRequestPB*>(req),
                       static_cast<ConsensusResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["UpdateConsensus"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new VoteRequestPB());
    mi->resp_prototype.reset(new VoteResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_RequestConsensusVote.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->RequestConsensusVote(static_cast<const VoteRequestPB*>(req),
                       static_cast<VoteResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["RequestConsensusVote"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new ChangeConfigRequestPB());
    mi->resp_prototype.reset(new ChangeConfigResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_ChangeConfig.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->ChangeConfig(static_cast<const ChangeConfigRequestPB*>(req),
                       static_cast<ChangeConfigResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["ChangeConfig"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new GetNodeInstanceRequestPB());
    mi->resp_prototype.reset(new GetNodeInstanceResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_GetNodeInstance.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->GetNodeInstance(static_cast<const GetNodeInstanceRequestPB*>(req),
                       static_cast<GetNodeInstanceResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["GetNodeInstance"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new RunLeaderElectionRequestPB());
    mi->resp_prototype.reset(new RunLeaderElectionResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_RunLeaderElection.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->RunLeaderElection(static_cast<const RunLeaderElectionRequestPB*>(req),
                       static_cast<RunLeaderElectionResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["RunLeaderElection"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new LeaderStepDownRequestPB());
    mi->resp_prototype.reset(new LeaderStepDownResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_LeaderStepDown.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->LeaderStepDown(static_cast<const LeaderStepDownRequestPB*>(req),
                       static_cast<LeaderStepDownResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["LeaderStepDown"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new GetLastOpIdRequestPB());
    mi->resp_prototype.reset(new GetLastOpIdResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_GetLastOpId.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->GetLastOpId(static_cast<const GetLastOpIdRequestPB*>(req),
                       static_cast<GetLastOpIdResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["GetLastOpId"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new GetConsensusStateRequestPB());
    mi->resp_prototype.reset(new GetConsensusStateResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_GetConsensusState.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->GetConsensusState(static_cast<const GetConsensusStateRequestPB*>(req),
                       static_cast<GetConsensusStateResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["GetConsensusState"] = std::move(mi);
  }
  {
    scoped_refptr<RpcMethodInfo> mi(new RpcMethodInfo());
    mi->req_prototype.reset(new StartTabletCopyRequestPB());
    mi->resp_prototype.reset(new StartTabletCopyResponsePB());
    mi->track_result = false;
    mi->handler_latency_histogram =
        METRIC_handler_latency_base_consensus_ConsensusService_StartTabletCopy.Instantiate(entity);
    mi->func = [this](const Message* req, Message* resp, RpcContext* ctx) {
      this->StartTabletCopy(static_cast<const StartTabletCopyRequestPB*>(req),
                       static_cast<StartTabletCopyResponsePB*>(resp),
                       ctx);
    };
    methods_by_name_["StartTabletCopy"] = std::move(mi);
  }
}

ConsensusServiceIf::~ConsensusServiceIf() {
}

std::string ConsensusServiceIf::service_name() const {
  return "base.consensus.ConsensusService";
}
std::string ConsensusServiceIf::static_service_name() {
  return "base.consensus.ConsensusService";
}

} // namespace consensus
} // namespace base
